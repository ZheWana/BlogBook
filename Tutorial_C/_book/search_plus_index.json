<<<<<<< HEAD
{"./":{"url":"./","title":"前言","keywords":"","body":"前言 《C语言食用手册》（以下简称本书）是C语言小菜鸟ZheWana的第一个相对完整的系列教程。它所承担的职责主要有两个： 帮助编者从最开始回顾编者所掌握的关于C语言的知识，并进行系统性的梳理； 帮助读者从头开始对C语言这门编程语言建立起浅显的了解； 由于全部内容均为笔者一人编写，难免有疏漏之处，还望读者斧正。 发现问题的读者，或者您有什么意见和建议，都可以移步手册的仓库BlogBook提出Issue，笔者会尽快回复和处理。 "},"背景.html":{"url":"背景.html","title":"背景","keywords":"","body":"背景 不得不说，无论今天我们作为一个程序员站在互联网巨人的哪个部分，C语言绝对都是一个值得歌颂的伟大发明。 你我可能不用C语言来完成我们的工作，但是C语言早已经渗透在了我们计算机世界的每个角落。 C语言的历史 C语言过于耀眼，笔者尚不够资格对其品头论足，在此仅将相关的历史进行罗列供读者了解： C语言最初是为Unix系统设计出来的工具，其源于一种无类型的语言：BCPL（B语言） 1967年，马丁·理查德设计实现了BCPL语言； 1970年，肯·汤普逊为Unix设计了一个精简版的BCPL，称为B语言； 随后，在肯·汤普逊和丹尼·里奇移植Unix系统的过程中，遇到了无类型语言与不同规格数据之间的冲突问题，于是便有了最初的C语言； 1973年，Unix系统的内核正式改用C语言编写，此后，C语言逐渐开始呗广泛的应用起来，彼时的C语言还没有一个正式的标准； 1988年，美国国家标准协会（ANSI）正式将 C 语言标准化。 C语言的版本 历史上C语言存在着多个版本，一些版本到今天已经弃用，但是大部分版本到今天仍然可以看到它们的存在。 K&R C（柯里C） 1978年，丹尼斯·里奇和布莱恩·柯林汉合作出版了《C程序设计语言》的第一版，彼时的C语言尚未拥有一个正式的标准，因此书中介绍的C语言标准也被C语言程序员称作K&R C（柯里C） 此处的K&R就是取两位作者的姓名首字母结合而成。 ANSI C（C89） 1989年，C语言被美国国家标准协会（ANSI）标准化。这个版本又称为C89。标准化的一个目的是扩展K&R C，增加了一些新特性。 ISO C（C90） 1990年，国际标准化组织（ISO）成立工作组，来规定国际标准的C语言，通过对ANSI标准的少量修改，最终制定了 ISO 9899:1990，又称为C90。随后不久被ANSI所接受。 C99 《标准修正案一》在1994年为C语言建立了一个新标准，但是只修正了一些C89标准中的细节和增加更多更广的国际字符集支持。不过，这个标准引出了1999年ISO 9899:1999的发表。它通常被称为C99。C99被ANSI于2000年3月采用。 此外，该版本为目前最为流行的C版本。 C11 2011年12月8日，ISO正式发布了新的C语言的新标准C11（之前被称为C1X），官方名称为ISO/IEC 9899:2011。新的标准提高了对C++的兼容性，并增加了一些新的特性。 C18（C17） C18（也被称为为C17）是ISO/IEC 9899:2018的非正式名称，是截止到2020年6月为止最新的C语言编程标准。它于2017年编写并于2018年6月发布，被用来替代C11标准（即ISO/IEC 9899:2011）。 C18标准将被C2x标准所取代。 C2x ISO正在讨论的C语言的下一个版本，尚未知发布时间。 以上便是一系列与C语言相关的背景知识，记不住？搞不懂？没关系，因为笔者也记不住。这并不会对你接下来的学习生涯造成多么巨大的影响，你需要的是坚持这种美好的品质。 参考内容： 维基百科----C语言的历史 "},"快速上手.html":{"url":"快速上手.html","title":"快速上手","keywords":"","body":"快速上手 入门程序世界的第一件事往往是和世界打招呼，那么我们入门C语言当然也采用相同的方式。 前排提醒： 该节部分内容可能对于初学者有些超纲，别担心，慢慢就懂了。 推荐读者在阅读后面章节的时候不时回来看看😁 Hello World 笔者在这里偷偷放一个HelloWorld程序： #include int main(){ printf(\"Hello World!\"); return 0; } 代码讲解 首先我们需要知道的是：上面的代码是写在一个以.c为后缀的文本文件里面的。如何最方便的得到这样一个文件呢？ 我们只需要在任意目录新建一个文本文件，然后将其重命名为xxx.c，其中xxx的部分可以是任何名称。 接下来我们来简单的解读一下这段代码都做了什么： 使用预处理指令#include，引入了位于stdio.h文件中的内容； 参考内容：预处理、标准库 定义了主函数：main； 在主函数中调用了stdio中的printf函数，向终端输出Hello World！； 设置主函数的返回值为0； 运行过程 此处笔者简单介绍一下一个C程序在实际运行之前需要讲过的步骤：编辑、编译、链接、运行。 编辑 顾名思义，就是编辑代码内容。笔者之前也说过：C程序的代码其实就是存储在一个以.c为后缀的文本文件中的，这一步我们需要做的事就是按照C语言的语法编辑这个文本文件的内容。 编辑文本文件可以使用的工具很多，最简单的当然就是Windows自带的记事本： 但是真正的代码编写往往不使用记事本来完成，相关话题我们会在后续的开发环境小节讲述到。 编译 编译文件所用到的工具叫做编译器，而需要编译器参与编译生成可执行文件的语言往往被称为编译型语言，C语言是其中最典型的代表。 相对的，还有多种语言的执行是由解释器一边解释一边执行的，我们称其为解释型语言，最典型的代表是Python。 编译器并不是一个特指，而是一类工具的简称。显然，有许多种编译器。其中最具代表性的就是许多Linux发行版作为标准编译器的GCC以及被AppleMacOS作为标准的Clang/LLVM，而此处我们一般常用的就是GCC编译器。 C语言编译的过程大体可以分为两个步骤：预处理和汇编。 其中预处理的主要作用是带有简单选择判断机制的替换： 依照#if指令来进行一些简单的判断 替换#include指令为其所包含的目录 替换#define所声明的宏为其所定义的内容 ...... 而汇编的主要作用说的简单点其实就是把C代码翻译成汇编代码。 注：此处内容涉及计算机基础知识，没有相关基础的读者可以尝试通过这个视频合集来完善自己的相关知识基础。 别担心，每集十分钟左右，刚好适合边吃饭边消遣着观看😋 链接 我们的代码中往往有许多符号（变量、函数等），而这些符号在使用的其实仅仅是一个符号而已，链接过程所做的事其实就是把这些普通的符号和他们的定义链接到一起，以便它们有自己的意义。 链接的工作往往由链接器来完成。 链接后的最终结果就是生成了可执行程序（.exe），接着就可以运行程序了。 开发环境 上面笔者提到了真正的代码编辑往往并不会使用记事本来进行，下面我们就来仔细聊聊C语言的开发环境。 常规的开发为了方便，我们一般使用集成开发环境（IDE，Integrated Development Environment）。IDE往往将我们上述提到的工具（编译器、链接器）集成到一起进行统一安装和管理，此外还带有一定的编辑文件以及方便软件开发的其他功能（例如代码高亮、代码补全、快速重构等）。 由于C++与C语言的密切关系，所以我们往往将C与C++相提并论，常用的C/C++集成开发环境有： 由微软推出的Visual Studio（简称VS） 由JetBrains推出的Clion 由BloodshedSoftware推出的Dev-C++ 部分学校的教学中使用的是老旧的VS2010版本，如果读者希望使用VS进行开发的话，建议使用微软每年在官网发布的最新社区版本（笔者落笔时最新版本为VS2022），网络上相关安装教程泛滥，恕笔者此处不再给出单独的安装教程。 笔者此处抱着一种夹带私货的态度，推荐读者使用Clion进行C语言的开发学习。 此外，既然已经决定开始学习编程，笔者同样推荐读者去看看笔者之前曾写过的一篇文章：编程Q&A—-环境&Tips，看不懂没关系，过段时间回来说不定就可以看懂了（doge 以上就是快速上手C语言相关的一些知识，还是那句话：没看懂没关系，看个热闹嘛，毕竟慢慢就懂了😋 "},"概念术语.html":{"url":"概念术语.html","title":"概念术语","keywords":"","body":"概念术语 当我们在和其他人交流一个特定的话题的时候，不可避免的会涉及到相关的术语，本节我们就来介绍一下C语言一些相关的术语。 标识符与关键字 先来说标识符。 标识符其实就是“名字”，我们可以为编程过程中的函数、变量、指针、结构体与联合体等进行命名（以下统称为标识符命名），而我们给他们起的名字就叫做标识符。标识符命名具有有一定的规则： 只能由字母、数字和下划线组成； 不能以数字开头； 有一定的长度限制（一般因编译器而异，但是一般都不会触及长度限制）； 此外需要补充的是：C语言的标识符是大小写敏感的，即：var与Var在C语言中会被视为两个不同的标识符。 一个对规则的简单概括其实就是：我们可以为标识符起一个不带标点（包括空格）的、由任意形式（大小写、顺序）的字母构成的、长度任意的、不可重复的名字。换句话说，我们从英文字典中随便拎出一个单词都可以作为标识符，甚至乱序的字母组合（例如：alksjdhgflakjs）也可以作为标识符。 说到这我们来引出关键字。 上面提到了，任意的字母组合都可以作为标识符，但是部分语言内特性（比如分支、循环等）也需要占用部分单词，所以这部分具有特殊意义的单词就不能用作标识符，我们为这部分特殊的单词规定了特殊的术语----关键字。 C语言中基本常用的关键字如下： 关键字 功能 auto 修饰关键字，默认的变量修饰关键字 break 语句，跳出整个循环 case 语句，与switch语句搭配，用于进入特定分支 char 类型声明，声明字符型的变量或返回字符类型的函数 const 修饰关键字，用于定义常量 continue 语句，结束当前循环，开始下一次循环 default 语句，与switch语句搭配，用于进入其他分支 do 语句，后面紧跟的语句块将作为循环的循环体 double 类型声明，声明双精度浮点型的变量或返回双精度浮点类型的函数 else 语句，与if语句搭配，用于进入其他分支 enum 类型声明，用于声明枚举类型 extern 修饰关键字，用于指明被修饰的变量或函数将在其他文件中定义 float 类型声明，声明单精度浮点型的变量或返回单精度浮点类型的函数 for 语句，用于构建循环 goto 语句，用于函数内无条件跳转 if 语句，用于进入分支 int 类型声明，声明整型的变量或返回整型的函数 long 修饰关键字，用于定义长类型的变量 register 修饰关键字，用于指明被修饰的变量为寄存器类型 return 语句，用于函数返回 short 修饰关键字，用于定义短类型的变量 signed 修饰关键字，用于定义有符号类型的变量 sizeof 语句，用于计算变量长度（单位为字节数） static 修饰关键字，用于声明静态变量 struct 类型声明，用于声明结构体类型 switch 语句，用于构建分支结构 typedef 用于给一致的数据类型取别名 union 类型声明，用于声明联合体类型 unsigned 修饰关键字，用于定义无符号类型的变量 void 类型声明，用于声明返回无类型或无参数函数，以及无类型指针 volatile 修饰关键字，用于指明被修饰的变量可能随时被该程序外的其他因素改变 while 语句，用于构建循环 此外还有有后续各标准引进的关键字： C99引进的：inline、restrict、_Bool、_Complex、_Imaginary C11引进的：_Alignas、_Alignof、_Atomic、_Generic、_Noreturn、_Static_Assert、_Thread_Local 考虑到真正的C23标准尚未发布，一些即将在C23标准中引入的关键字就不在此处提及了。 空白符与注释 首先我们来了解一下什么叫做空白符：空白符，顾名思义，就是那些展示出的效果是空白的字符。例如：空格（`）、制表符（ `）、换行与回车等。 C语言中对于空白符是不敏感的。 也就是说，在同一个语句的语法解析中，多余的空格或其他空白符最终会被忽略。举个简单的例子，在实际的语法解析中，下面两段代码是等价的： // 示例代码1 int a = 100; // 示例代码2 int a = 100; 同理，在不同语句之间的换行其实也是不影响语法表达的，故以下几段代码的表达仍然是等价的： // 示例代码3 int a = 1,b = 2,c; c = b + a; // 示例代码4 int a = 1,b = 2,c;c = b + a; // 示例代码5 int a = 1,b = 2,c; c = b + a; 不难看出，虽然空白符对于代码的语法表达并没有什么大的影响，但是空白符对代码的可读性影响其实是很大的。因此笔者在此处建议读者从一开始学习C语言的时候就应该养成良好的编程习惯，利用好空白符来提高代码的可读性。 说完了空白符我们再来说说注释： 看了上面的示例，虽然读者并不一定能够看懂代码的内容，但是应该不难注意到每一段的开头都添加了这样的内容：// 示例代码x，用来说明这段代码的作用。这种说明性质的内容在C语言或者说绝大部分编程语言中都拥有一个共同的名字----注释。 所谓注释，即批注与解释，其在代码中没有任何实际作用，仅仅是起到一个对代码的解释说明的作用。 C语言中的注释语法有两种：行注释和块注释。 顾名思义，行注释就是标志着从注释符号开始当前行的内容作为注释存在，语法上使用//来表示，例子就如同上面写的// 示例代码x。 而块注释则代表着对一块内容进行注释，语法上使用/*来表示注释的开始，并且使用*/来表示注释的结束。举个简单的例子： /*这是第一行注释 这是第二行注释 这是第三行注释 */int a = 0; 显然，夹在/*和*/之间的内容被作为了注释，而不在中间的内容，即使和*/在同一行内也会被认为是代码的一部分。（当然一般出于可读性考虑也不会把*/和下一行代码放在同一行内。） 语句、表达式与语句块 先来说说语句： 一个完整的C代码一定是由无数的语句构成的，而一个语句就像是我们说的一句话，往往能够表达一个完整的意思。 正因为一个语句就具有一个完整的意思，所以在每个完整的语句后，都需要用一个英文分号;来将多个语句分开。 这是一个合法的语句：int a = 0; 而这样的语句就会被认为是不合法的：int a = 0 不得不提到的一件事情是：在C语言初学者易犯的错误中，忘加分号或者用错分号（用成中文分号；）往往高居榜首。 此外还需要提到的一件事是：单独的分号是可以作为一个语句的，我们称其为空语句，但是空语句不但没有任何实际意义，还会在特定情况下影响到代码的可读性，故很少使用。 接下来说说表达式： C语言中所谓的表达式其实和数学中的表达式概念十分相似，都是指一系列运算符与数字的组合，用于获取一系列计算的值。 一般表达式都会将一系列运算的结果作为返回值，表达式本身不构成语句，但是可以作为语句的组成部分。例如： int a = 8 + 10; 其中8 + 10就是一个典型的表达式，其作用是返回数学计算的值作为变量a的初始值。 最后我们来说一说语句块： 在C语言中，我们将用一对花括号括起来的一系列语句称为一个语句块，例如： {// 插播复习：行注释的用法，以及多余空白符会被忽视 int a = 0; int b = a + 15; } 值得注意的是，花括号具有限制变量作用域的作用，即花括号内的变量的作用域仅限于变量定义后以及花括号结束前。（不知道作用域是什么没关系，看完变量章节再回来回顾即可） 此外，语句块之后并不需要另加分号。 "},"数据类型.html":{"url":"数据类型.html","title":"数据类型","keywords":"","body":"数据类型 "},"变量与常量.html":{"url":"变量与常量.html","title":"变量与常量","keywords":"","body":"变量与常量 "},"运算符.html":{"url":"运算符.html","title":"运算符","keywords":"","body":"运算符 "},"逻辑控制/":{"url":"逻辑控制/","title":"逻辑控制","keywords":"","body":"逻辑控制 "},"逻辑控制/分支控制.html":{"url":"逻辑控制/分支控制.html","title":"分支控制","keywords":"","body":"分支控制 "},"逻辑控制/循环控制.html":{"url":"逻辑控制/循环控制.html","title":"循环控制","keywords":"","body":"循环控制 "},"逻辑控制/自由控制.html":{"url":"逻辑控制/自由控制.html","title":"自由控制","keywords":"","body":"自由控制 "},"内容封装/":{"url":"内容封装/","title":"内容封装","keywords":"","body":"内容封装 "},"内容封装/数据封装.html":{"url":"内容封装/数据封装.html","title":"数据封装","keywords":"","body":"数据封装 "},"内容封装/字符封装.html":{"url":"内容封装/字符封装.html","title":"字符封装","keywords":"","body":"字符封装 "},"内容封装/操作封装.html":{"url":"内容封装/操作封装.html","title":"操作封装","keywords":"","body":"操作封装 "},"引用与链接.html":{"url":"引用与链接.html","title":"引用与链接","keywords":"","body":"引用与链接 "},"预处理.html":{"url":"预处理.html","title":"预处理","keywords":"","body":"预处理 "},"内存模型.html":{"url":"内存模型.html","title":"内存模型","keywords":"","body":"内存模型 "},"标准库.html":{"url":"标准库.html","title":"标准库","keywords":"","body":"标准库 "}}
=======
{"./":{"url":"./","title":"前言","keywords":"","body":"前言 《C语言食用手册》（以下简称本书）是C语言小菜鸟ZheWana的第一个相对完整的系列教程。它所承担的职责主要有两个： 帮助编者从最开始回顾编者所掌握的关于C语言的知识，并进行系统性的梳理； 帮助读者从头开始对C语言这门编程语言建立起浅显的了解； 由于全部内容均为笔者一人编写，难免有疏漏之处，还望读者斧正。 发现问题的读者，或者您有什么意见和建议，都可以移步手册的仓库BlogBook提出Issue，笔者会尽快回复和处理。 "},"背景.html":{"url":"背景.html","title":"背景","keywords":"","body":"背景 不得不说，无论今天我们作为一个程序员站在互联网巨人的哪个部分，C语言绝对都是一个值得歌颂的伟大发明。 你我可能不用C语言来完成我们的工作，但是C语言早已经渗透在了我们计算机世界的每个角落。 C语言的历史 C语言过于耀眼，笔者尚不够资格对其品头论足，在此仅将相关的历史进行罗列供读者了解： C语言最初是为Unix系统设计出来的工具，其源于一种无类型的语言：BCPL（B语言） 1967年，马丁·理查德设计实现了BCPL语言； 1970年，肯·汤普逊为Unix设计了一个精简版的BCPL，称为B语言； 随后，在肯·汤普逊和丹尼·里奇移植Unix系统的过程中，遇到了无类型语言与不同规格数据之间的冲突问题，于是便有了最初的C语言； 1973年，Unix系统的内核正式改用C语言编写，此后，C语言逐渐开始呗广泛的应用起来，彼时的C语言还没有一个正式的标准； 1988年，美国国家标准协会（ANSI）正式将 C 语言标准化。 C语言的版本 历史上C语言存在着多个版本，一些版本到今天已经弃用，但是大部分版本到今天仍然可以看到它们的存在。 K&R C（柯里C） 1978年，丹尼斯·里奇和布莱恩·柯林汉合作出版了《C程序设计语言》的第一版，彼时的C语言尚未拥有一个正式的标准，因此书中介绍的C语言标准也被C语言程序员称作K&R C（柯里C） 此处的K&R就是取两位作者的姓名首字母结合而成。 ANSI C（C89） 1989年，C语言被美国国家标准协会（ANSI）标准化。这个版本又称为C89。标准化的一个目的是扩展K&R C，增加了一些新特性。 ISO C（C90） 1990年，国际标准化组织（ISO）成立工作组，来规定国际标准的C语言，通过对ANSI标准的少量修改，最终制定了 ISO 9899:1990，又称为C90。随后不久被ANSI所接受。 C99 《标准修正案一》在1994年为C语言建立了一个新标准，但是只修正了一些C89标准中的细节和增加更多更广的国际字符集支持。不过，这个标准引出了1999年ISO 9899:1999的发表。它通常被称为C99。C99被ANSI于2000年3月采用。 此外，该版本为目前最为流行的C版本。 C11 2011年12月8日，ISO正式发布了新的C语言的新标准C11（之前被称为C1X），官方名称为ISO/IEC 9899:2011。新的标准提高了对C++的兼容性，并增加了一些新的特性。 C18（C17） C18（也被称为为C17）是ISO/IEC 9899:2018的非正式名称，是截止到2020年6月为止最新的C语言编程标准。它于2017年编写并于2018年6月发布，被用来替代C11标准（即ISO/IEC 9899:2011）。 C18标准将被C2x标准所取代。 C2x ISO正在讨论的C语言的下一个版本，尚未知发布时间。 以上便是一系列与C语言相关的背景知识，记不住？搞不懂？没关系，因为笔者也记不住。这并不会对你接下来的学习生涯造成多么巨大的影响，你需要的是坚持这种美好的品质。 参考内容： 维基百科----C语言的历史 "},"快速上手.html":{"url":"快速上手.html","title":"快速上手","keywords":"","body":"快速上手 入门程序世界的第一件事往往是和世界打招呼，那么我们入门C语言当然也采用相同的方式。 前排提醒： 该节部分内容可能对于初学者有些超纲，别担心，慢慢就懂了。 推荐读者在阅读后面章节的时候不时回来看看😁 Hello World 笔者在这里偷偷放一个HelloWorld程序： #include int main(){ printf(\"Hello World!\"); return 0; } 代码讲解 首先我们需要知道的是：上面的代码是写在一个以.c为后缀的文本文件里面的。如何最方便的得到这样一个文件呢？ 我们只需要在任意目录新建一个文本文件，然后将其重命名为xxx.c，其中xxx的部分可以是任何名称。 接下来我们来简单的解读一下这段代码都做了什么： 使用预处理指令#include，引入了位于stdio.h文件中的内容； 参考内容：预处理、标准库 定义了主函数：main； 在主函数中调用了stdio中的printf函数，向终端输出Hello World！； 设置主函数的返回值为0； 运行过程 此处笔者简单介绍一下一个C程序在实际运行之前需要讲过的步骤：编辑、编译、链接、运行。 编辑 顾名思义，就是编辑代码内容。笔者之前也说过：C程序的代码其实就是存储在一个以.c为后缀的文本文件中的，这一步我们需要做的事就是按照C语言的语法编辑这个文本文件的内容。 编辑文本文件可以使用的工具很多，最简单的当然就是Windows自带的记事本： 但是真正的代码编写往往不使用记事本来完成，相关话题我们会在后续的开发环境小节讲述到。 编译 编译文件所用到的工具叫做编译器，而需要编译器参与编译生成可执行文件的语言往往被称为编译型语言，C语言是其中最典型的代表。 相对的，还有多种语言的执行是由解释器一边解释一边执行的，我们称其为解释型语言，最典型的代表是Python。 编译器并不是一个特指，而是一类工具的简称。显然，有许多种编译器。其中最具代表性的就是许多Linux发行版作为标准编译器的GCC以及被AppleMacOS作为标准的Clang/LLVM，而此处我们一般常用的就是GCC编译器。 C语言编译的过程大体可以分为两个步骤：预处理和汇编。 其中预处理的主要作用是带有简单选择判断机制的替换： 依照#if指令来进行一些简单的判断 替换#include指令为其所包含的目录 替换#define所声明的宏为其所定义的内容 ...... 而汇编的主要作用说的简单点其实就是把C代码翻译成汇编代码。 注：此处内容涉及计算机基础知识，没有相关基础的读者可以尝试通过这个视频合集来完善自己的相关知识基础。 别担心，每集十分钟左右，刚好适合边吃饭边消遣着观看😋 链接 我们的代码中往往有许多符号（变量、函数等），而这些符号在使用的其实仅仅是一个符号而已，链接过程所做的事其实就是把这些普通的符号和他们的定义链接到一起，以便它们有自己的意义。 链接的工作往往由链接器来完成。 链接后的最终结果就是生成了可执行程序（.exe），接着就可以运行程序了。 开发环境 上面笔者提到了真正的代码编辑往往并不会使用记事本来进行，下面我们就来仔细聊聊C语言的开发环境。 常规的开发为了方便，我们一般使用集成开发环境（IDE，Integrated Development Environment）。IDE往往将我们上述提到的工具（编译器、链接器）集成到一起进行统一安装和管理，此外还带有一定的编辑文件以及方便软件开发的其他功能（例如代码高亮、代码补全、快速重构等）。 由于C++与C语言的密切关系，所以我们往往将C与C++相提并论，常用的C/C++集成开发环境有： 由微软推出的Visual Studio（简称VS） 由JetBrains推出的Clion 由BloodshedSoftware推出的Dev-C++ 部分学校的教学中使用的是老旧的VS2010版本，如果读者希望使用VS进行开发的话，建议使用微软每年在官网发布的最新社区版本（笔者落笔时最新版本为VS2022），网络上相关安装教程泛滥，恕笔者此处不再给出单独的安装教程。 笔者此处抱着一种夹带私货的态度，推荐读者使用Clion进行C语言的开发学习。 此外，既然已经决定开始学习编程，笔者同样推荐读者去看看笔者之前曾写过的一篇文章：编程Q&A—-环境&Tips，看不懂没关系，过段时间回来说不定就可以看懂了（doge 以上就是快速上手C语言相关的一些知识，还是那句话：没看懂没关系，看个热闹嘛，毕竟慢慢就懂了😋 "},"概念术语.html":{"url":"概念术语.html","title":"概念术语","keywords":"","body":"概念术语 当我们在和其他人交流一个特定的话题的时候，不可避免的会涉及到相关的术语，本节我们就来介绍一下C语言一些相关的术语。 标识符与关键字 先来说标识符。 标识符其实就是“名字”，我们可以为编程过程中的函数、变量、指针、结构体与联合体等进行命名（以下统称为标识符命名），而我们给他们起的名字就叫做标识符。标识符命名具有有一定的规则： 只能由字母、数字和下划线组成； 不能以数字开头； 有一定的长度限制（一般因编译器而异，但是一般都不会触及长度限制）； 此外需要补充的是：C语言的标识符是大小写敏感的，即：var与Var在C语言中会被视为两个不同的标识符。 一个对规则的简单概括其实就是：我们可以为标识符起一个不带标点（包括空格）的、由任意形式（大小写、顺序）的字母构成的、长度任意的、不可重复的名字。换句话说，我们从英文字典中随便拎出一个单词都可以作为标识符，甚至乱序的字母组合（例如：alksjdhgflakjs）也可以作为标识符。 说到这我们来引出关键字。 上面提到了，任意的字母组合都可以作为标识符，但是部分语言内特性（比如分支、循环等）也需要占用部分单词，所以这部分具有特殊意义的单词就不能用作标识符，我们为这部分特殊的单词规定了特殊的术语----关键字。 C语言中基本常用的关键字如下： 关键字 功能 auto 修饰关键字，默认的变量修饰关键字 break 语句，跳出整个循环 case 语句，与switch语句搭配，用于进入特定分支 char 类型声明，声明字符型的变量或返回字符类型的函数 const 修饰关键字，用于定义常量 continue 语句，结束当前循环，开始下一次循环 default 语句，与switch语句搭配，用于进入其他分支 do 语句，后面紧跟的语句块将作为循环的循环体 double 类型声明，声明双精度浮点型的变量或返回双精度浮点类型的函数 else 语句，与if语句搭配，用于进入其他分支 enum 类型声明，用于声明枚举类型 extern 修饰关键字，用于指明被修饰的变量或函数将在其他文件中定义 float 类型声明，声明单精度浮点型的变量或返回单精度浮点类型的函数 for 语句，用于构建循环 goto 语句，用于函数内无条件跳转 if 语句，用于进入分支 int 类型声明，声明整型的变量或返回整型的函数 long 修饰关键字，用于定义长类型的变量 register 修饰关键字，用于指明被修饰的变量为寄存器类型 return 语句，用于函数返回 short 修饰关键字，用于定义短类型的变量 signed 修饰关键字，用于定义有符号类型的变量 sizeof 语句，用于计算变量长度（单位为字节数） static 修饰关键字，用于声明静态变量 struct 类型声明，用于声明结构体类型 switch 语句，用于构建分支结构 typedef 用于给一致的数据类型取别名 union 类型声明，用于声明联合体类型 unsigned 修饰关键字，用于定义无符号类型的变量 void 类型声明，用于声明返回无类型或无参数函数，以及无类型指针 volatile 修饰关键字，用于指明被修饰的变量可能随时被该程序外的其他因素改变 while 语句，用于构建循环 此外还有有后续各标准引进的关键字： C99引进的：inline、restrict、_Bool、_Complex、_Imaginary C11引进的：_Alignas、_Alignof、_Atomic、_Generic、_Noreturn、_Static_Assert、_Thread_Local 考虑到真正的C23标准尚未发布，一些即将在C23标准中引入的关键字就不在此处提及了。 空白符与注释 首先我们来了解一下什么叫做空白符：空白符，顾名思义，就是那些展示出的效果是空白的字符。例如：空格（`）、制表符（ `）、换行与回车等。 C语言中对于空白符是不敏感的。 也就是说，在同一个语句的语法解析中，多余的空格或其他空白符最终会被忽略。举个简单的例子，在实际的语法解析中，下面两段代码是等价的： // 示例代码1 int a = 100; // 示例代码2 int a = 100; 同理，在不同语句之间的换行其实也是不影响语法表达的，故以下几段代码的表达仍然是等价的： // 示例代码3 int a = 1,b = 2,c; c = b + a; // 示例代码4 int a = 1,b = 2,c;c = b + a; // 示例代码5 int a = 1,b = 2,c; c = b + a; 不难看出，虽然空白符对于代码的语法表达并没有什么大的影响，但是空白符对代码的可读性影响其实是很大的。因此笔者在此处建议读者从一开始学习C语言的时候就应该养成良好的编程习惯，利用好空白符来提高代码的可读性。 说完了空白符我们再来说说注释： 看了上面的示例，虽然读者并不一定能够看懂代码的内容，但是应该不难注意到每一段的开头都添加了这样的内容：// 示例代码x，用来说明这段代码的作用。这种说明性质的内容在C语言或者说绝大部分编程语言中都拥有一个共同的名字----注释。 所谓注释，即批注与解释，其在代码中没有任何实际作用，仅仅是起到一个对代码的解释说明的作用。 C语言中的注释语法有两种：行注释和块注释。 顾名思义，行注释就是标志着从注释符号开始当前行的内容作为注释存在，语法上使用//来表示，例子就如同上面写的// 示例代码x。 而块注释则代表着对一块内容进行注释，语法上使用/*来表示注释的开始，并且使用*/来表示注释的结束。举个简单的例子： /*这是第一行注释 这是第二行注释 这是第三行注释 */int a = 0; 显然，夹在/*和*/之间的内容被作为了注释，而不在中间的内容，即使和*/在同一行内也会被认为是代码的一部分。（当然一般出于可读性考虑也不会把*/和下一行代码放在同一行内。） 语句、表达式与语句块 先来说说语句： 一个完整的C代码一定是由无数的语句构成的，而一个语句就像是我们说的一句话，往往能够表达一个完整的意思。 正因为一个语句就具有一个完整的意思，所以在每个完整的语句后，都需要用一个英文分号;来将多个语句分开。 这是一个合法的语句：int a = 0; 而这样的语句就会被认为是不合法的：int a = 0 不得不提到的一件事情是：在C语言初学者易犯的错误中，忘加分号或者用错分号（用成中文分号；）往往高居榜首。 此外还需要提到的一件事是：单独的分号是可以作为一个语句的，我们称其为空语句，但是空语句不但没有任何实际意义，还会在特定情况下影响到代码的可读性，故很少使用。 接下来说说表达式： C语言中所谓的表达式其实和数学中的表达式概念十分相似，都是指一系列运算符与数字的组合，用于获取一系列计算的值。 一般表达式都会将一系列运算的结果作为返回值，表达式本身不构成语句，但是可以作为语句的组成部分。例如： int a = 8 + 10; 其中8 + 10就是一个典型的表达式，其作用是返回数学计算的值作为变量a的初始值。 最后我们来说一说语句块： 在C语言中，我们将用一对花括号括起来的一系列语句称为一个语句块，例如： {// 插播复习：行注释的用法，以及多余空白符会被忽视 int a = 0; int b = a + 15; } 值得注意的是，花括号具有限制变量作用域的作用，即花括号内的变量的作用域仅限于变量定义后以及花括号结束前。（不知道作用域是什么没关系，看完变量章节再回来回顾即可） 此外，语句块之后并不需要另加分号。 "},"数据类型.html":{"url":"数据类型.html","title":"数据类型","keywords":"","body":"数据类型 所谓数据类型，是指给不同类型的数据赋予不同的类型，以便于区分不同类型数据的运算方式以及其在内存中的存储方式。C语言中是有严格的数据类型区分的。 bit与Byte与内存存储 在实际理解各个数据类型之前，笔者需要先科普一些简单的概念。 任何数据在电脑中的存储其实都是以二进制的形式进行存储的，即只有0和1两种形式。 例如数字5在内存中的存储内容实际是101。 而在我们的描述中，往往把内存中的每一个0或1称为一个位，即bit。 在此基础上，我们将8个bit的组合称为一个字节，即Byte。 在C语言中，大部分内存相关的操作都是以字节为最小单位的，例如sizeof运算符的作用就是返回参数类型所占有的字节数。 数据类型概览 数据类型一般包括字符型、整型以及浮点型，此外还有取值离散的枚举类型、由各种基础类型组合而成的结构体以及空类型。 此处我们只介绍最基础的字符型、整型以及浮点型。 每个数据类型都有其对应的关键字，一般用于声明对应数据类型的变量： 类型 关键字 字符型 char 整型 int 浮点型 float、double 字符类型 要想了解字符类型，首先得了解如何表示数据类型。在C语言中，我们往往使用一对单引号来包裹一个字符，以便使其与一般的代码内容区分开。例如：'a' 需要强调的是，在一般的使用中，一对单引号内只能包裹一个字符。 注：在实际的C语言标准中并没有规定一对单引号中只能包裹一个字符，但是这种写法实际使用中极易在数据类型转换中丢失内容，并且不符合我们编写代码清晰易懂的原则，所以请尽量不要用到实际的代码编写中。 计算机之所以称为计算机，是因为他们的作用主要是计算。我们之前也提到过：任何数据在电脑中的存储其实都是以二进制的形式进行存储的，即只有0和1两种形式。说到这里相信读者很容易就会想到一个问题：字符该怎么使用二进制进行存储呢？ 这个问题就很好的引出了我们接下来要讲述的内容----ASCII。 ASCII全称为American Standard Code for Information Interchange，译为美国信息互换标准代码。ASCII的内容其实就是一张对照表，其中规定了一些常见的字符与数字的对应关系，例如小写字母a在表中就规定与数字61对应。完整的ASCII表将会在本章节末附上。 在之前的章节中我们了解了C语言中有一部分保留的关键字，其中char关键字用于声明字符类型相关的变量，例如，我们可以用以下代码来声明一个字符类型的变量： char a = 'a'; 字符类型的变量在内存中所占据的大小是一个字节，一个字节的空间实际上可以表示256个不同的数字， 而在实际的使用中，如果不考虑ASCII的对应关系的话，其实字符型内存储的就是一串简单的数字，可以像一般变量一样参与数字运算。此外，在ASCII覆盖的范围内，将字符变量赋值为字符或者数字都是等效的，例如： char a = 'a'; char a = 97; 出于避免读者混淆的目的，笔者在此处强调一下数字与字符的关系： 以下两句代码声明的变量实际上具有不同的值： char a = 0; char b = '0'; 其中，a被赋值为数字零，其值为0；b被赋值为字符零，其值为48。综上，请读者在使用的时候注意区分数字与字符的区别。 整型 浮点型 附：ASCII码对照表 二进制 十进制 十六进制 字符/缩写 解释 00000000 0 00 NUL (NULL) 空字符 00000001 1 01 SOH (Start Of Headling) 标题开始 00000010 2 02 STX (Start Of Text) 正文开始 00000011 3 03 ETX (End Of Text) 正文结束 00000100 4 04 EOT (End Of Transmission) 传输结束 00000101 5 05 ENQ (Enquiry) 请求 00000110 6 06 ACK (Acknowledge) 回应/响应/收到通知 00000111 7 07 BEL (Bell) 响铃 00001000 8 08 BS (Backspace) 退格 00001001 9 09 HT (Horizontal Tab) 水平制表符 00001010 10 0A LF/NL(Line Feed/New Line) 换行键 00001011 11 0B VT (Vertical Tab) 垂直制表符 00001100 12 0C FF/NP (Form Feed/New Page) 换页键 00001101 13 0D CR (Carriage Return) 回车键 00001110 14 0E SO (Shift Out) 不用切换 00001111 15 0F SI (Shift In) 启用切换 00010000 16 10 DLE (Data Link Escape) 数据链路转义 00010001 17 11 DC1/XON (Device Control 1/Transmission On) 设备控制1/传输开始 00010010 18 12 DC2 (Device Control 2) 设备控制2 00010011 19 13 DC3/XOFF (Device Control 3/Transmission Off) 设备控制3/传输中断 00010100 20 14 DC4 (Device Control 4) 设备控制4 00010101 21 15 NAK (Negative Acknowledge) 无响应/非正常响应/拒绝接收 00010110 22 16 SYN (Synchronous Idle) 同步空闲 00010111 23 17 ETB (End of Transmission Block) 传输块结束/块传输终止 00011000 24 18 CAN (Cancel) 取消 00011001 25 19 EM (End of Medium) 已到介质末端/介质存储已满/介质中断 00011010 26 1A SUB (Substitute) 替补/替换 00011011 27 1B ESC (Escape) 逃离/取消 00011100 28 1C FS (File Separator) 文件分割符 00011101 29 1D GS (Group Separator) 组分隔符/分组符 00011110 30 1E RS (Record Separator) 记录分离符 00011111 31 1F US (Unit Separator) 单元分隔符 00100000 32 20 (Space) 空格 00100001 33 21 ! 00100010 34 22 \" 00100011 35 23 # 00100100 36 24 $ 00100101 37 25 % 00100110 38 26 & 00100111 39 27 ' 00101000 40 28 ( 00101001 41 29 ) 00101010 42 2A * 00101011 43 2B + 00101100 44 2C , 00101101 45 2D - 00101110 46 2E . 00101111 47 2F / 00110000 48 30 0 00110001 49 31 1 00110010 50 32 2 00110011 51 33 3 00110100 52 34 4 00110101 53 35 5 00110110 54 36 6 00110111 55 37 7 00111000 56 38 8 00111001 57 39 9 00111010 58 3A : 00111011 59 3B ; 00111100 60 3C 00111101 61 3D = 00111110 62 3E > 00111111 63 3F ? 01000000 64 40 @ 01000001 65 41 A 01000010 66 42 B 01000011 67 43 C 01000100 68 44 D 01000101 69 45 E 01000110 70 46 F 01000111 71 47 G 01001000 72 48 H 01001001 73 49 I 01001010 74 4A J 01001011 75 4B K 01001100 76 4C L 01001101 77 4D M 01001110 78 4E N 01001111 79 4F O 01010000 80 50 P 01010001 81 51 Q 01010010 82 52 R 01010011 83 53 S 01010100 84 54 T 01010101 85 55 U 01010110 86 56 V 01010111 87 57 W 01011000 88 58 X 01011001 89 59 Y 01011010 90 5A Z 01011011 91 5B [ 01011100 92 5C \\ 01011101 93 5D ] 01011110 94 5E ^ 01011111 95 5F _ 01100000 96 60 ` 01100001 97 61 a 01100010 98 62 b 01100011 99 63 c 01100100 100 64 d 01100101 101 65 e 01100110 102 66 f 01100111 103 67 g 01101000 104 68 h 01101001 105 69 i 01101010 106 6A j 01101011 107 6B k 01101100 108 6C l 01101101 109 6D m 01101110 110 6E n 01101111 111 6F o 01110000 112 70 p 01110001 113 71 q 01110010 114 72 r 01110011 115 73 s 01110100 116 74 t 01110101 117 75 u 01110110 118 76 v 01110111 119 77 w 01111000 120 78 x 01111001 121 79 y 01111010 122 7A z 01111011 123 7B { 01111100 124 7C \\ 01111101 125 7D } 01111110 126 7E ~ 01111111 127 7F DEL (Delete) 删除 "},"变量与常量.html":{"url":"变量与常量.html","title":"变量与常量","keywords":"","body":"变量与常量 "},"运算符.html":{"url":"运算符.html","title":"运算符","keywords":"","body":"运算符 "},"逻辑控制/":{"url":"逻辑控制/","title":"逻辑控制","keywords":"","body":"逻辑控制 "},"逻辑控制/分支控制.html":{"url":"逻辑控制/分支控制.html","title":"分支控制","keywords":"","body":"分支控制 "},"逻辑控制/循环控制.html":{"url":"逻辑控制/循环控制.html","title":"循环控制","keywords":"","body":"循环控制 "},"逻辑控制/自由控制.html":{"url":"逻辑控制/自由控制.html","title":"自由控制","keywords":"","body":"自由控制 "},"内容封装/":{"url":"内容封装/","title":"内容封装","keywords":"","body":"内容封装 "},"内容封装/数据封装.html":{"url":"内容封装/数据封装.html","title":"数据封装","keywords":"","body":"数据封装 "},"内容封装/字符封装.html":{"url":"内容封装/字符封装.html","title":"字符封装","keywords":"","body":"字符封装 "},"内容封装/操作封装.html":{"url":"内容封装/操作封装.html","title":"操作封装","keywords":"","body":"操作封装 "},"引用与链接.html":{"url":"引用与链接.html","title":"引用与链接","keywords":"","body":"引用与链接 "},"预处理.html":{"url":"预处理.html","title":"预处理","keywords":"","body":"预处理 "},"内存模型.html":{"url":"内存模型.html","title":"内存模型","keywords":"","body":"内存模型 "},"标准库.html":{"url":"标准库.html","title":"标准库","keywords":"","body":"标准库 "}}
>>>>>>> 9a990012b08adfb2e21a643e8c33b17d899bf945
